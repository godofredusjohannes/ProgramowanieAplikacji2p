<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Porównanie programowania obiektowego i strukturalnego.</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
<header>
    <h1><b>T03 - Porównanie programowania obiektowego i strukturalnego.</b></h1>
    <h2>Seweryn Poczynek 2P</h2>
</header>
<section>

    <h2><b>Programowanie strukturalne</b></h2>
    <ol>
            <li>
                Paradygmat programowania zakładający rozdzielenie
        funkcjonalności programu na moduły (podprogramy).
        Komunikują się one ze sobą przez określone interfejsy.
            </li>
            <li>
                Jest rozszerzeniem programowania proceduralnego
        (poprawa przejrzystości i jakości kodu oraz
        przyśpieszenie tworzenia oprogramowania).
            </li>
        </ol>

    <h2><b>Założenia programowania strukturalnego</b></h2>
    <ol>
        <li>
            Podzielone bloki kodu mają jeden punkt wejścia (mogą
            mieć wiele punktów wyjścia)
        </li>
        <li>
            Wykonywanie wyrażeń w określonej kolejności
        </li>
        <li>
            Używanie instrukcji warunkowych (if , if else)
        </li>
        <li>
            Używanie pętli (for, while, do while)
        </li>
        <li>
            Unikanie instrukcji skoku (goto)
        </li>
        <li>
            Unikanie instrukcji break, continue
        </li>
    </ol>

    <h2><b>Programowanie obiektowe</b></h2>
    <ol>
        <li>
            Paradygmat programowania zakładający reprezentację
            problemów w postaci obiektów, przypisanie im działań
            (metod), które mogą wykonywać oraz umieszczenie pól,
            które opisują dany obiekt.
        </li>
        <li>
            Jest to podejście bardziej naturalne dla ludzi, bardziej
            zgodne z rzeczywistością.
        </li>
    </ol>

    <h2><b>Założenia programowania obiektowego</b></h2>
    <ol>
        <li>
            Abstrakcja
        </li>
        <li>
            Hermetyzacja danych (enkapsulacja)
        </li>
        <li>
            Dziedziczenie
        </li>
        <li>
            Polimorfizm
        </li>
    </ol>

    <h2><b>Abstrakcja</b></h2>
    <ol>
        <li>
            Zredukowanie właściwości opisywanego obiektu do
            najbardziej podstawowych, ograniczenie zakresu
            funkcjonalności obiektu do kluczowych dla danego
            zagadnienia działań.
        </li>
        <li>
            Ukrycie funkcjonalności za interfejsem, uogólnienie
            implementacji.
        </li>
    </ol>

    <h2><b>Enkapsulacja</b></h2>
    <ol>
        <li>
            Inaczej hermetyzacja danych.
        </li>
        <li>
            Dostęp do składowych jest ograniczony za pomocą
            dobrze określonego interfejsu, czyli obiekt udostępnia
            tylko pewien zbiór metod, które są widoczne z zewnątrz i
            mogą być wywoływane.
        </li>
        <li>
            Dostęp do pól obiektu powinien być realizowany poprzez
            odpowiednie metody(Settery/gettery) a nie przez
            bezpośredni dostęp do nich.
        </li>
    </ol>

    <h2><b>Dziedziczenie</b></h2>
    <ol>
        <li>
            Mechanizm umożliwiający wywodzenie nowych klas z klas
            już istniejących, wraz z przejmowaniem ich metod. Dzięki
            czemu zyskujemy wszystkie już istniejące funkcjonalności,
            które dodatkowo możemy rozszerzyć lub zmienić.
        </li>
    </ol>

    <h2><b>Polimorfizm</b></h2>
    <ol>
        <li>
            Mechanizm pozwalający na używanie metod itp. na różny
            sposób, np. przeciążając metodę toString, aby akceptowała
            zmienne typu int, float, decimal i każdą z nich
            konwertowała właściwie do ciągu znakowego.
        </li>
    </ol>

    <h2><b>Różnice</b></h2>
    <ol>
        <li>
            W programowaniu strukturalnym mamy podprogramy
            (funkcje), które odpowiednio ułożone i wywołane tworzą
            program.
        </li>
        <li>
            Natomiast w p. obiektowym funkcjonalności są
            przypisane obiektom, zatem trudniej tutaj o pomyłkę np.
            taką jak przekazanie złej zmiennej do funkcji.
        </li>
    </ol>

</section>


</body>
</html>